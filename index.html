<!DOCTYPE html>
<html lang="fo">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Fjallaprædikan • Typing</title>
  <style>
    :root{
      --bg1: #0f172a;
      --bg2: #111827;
      --card: rgba(255,255,255,0.06);
      --border: rgba(255,255,255,0.12);
      --text: #e5e7eb;
      --muted: #94a3b8;
      --wrong: #ef4444;
      --ok: #22c55e;
      --hinted: #93c5fd;
      --accent: #38bdf8;
      --accent2: #22c55e;
      --shadow: 0 20px 60px rgba(0,0,0,0.35);
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      min-height: 100vh;
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      color: var(--text);
      background:
        radial-gradient(1200px 700px at 10% 10%, rgba(56,189,248,0.12), transparent 60%),
        radial-gradient(900px 700px at 90% 90%, rgba(34,197,94,0.10), transparent 60%),
        linear-gradient(160deg, var(--bg1), var(--bg2));
      display: grid;
      place-items: center;
      padding: 20px;
    }

    .wrap {
      width: min(1200px, 100%);
    }

    .card {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 20px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
      overflow: hidden;
    }

    .topbar {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
      justify-content: space-between;
      padding: 14px;
      border-bottom: 1px solid var(--border);
      background: rgba(255,255,255,0.02);
    }

    .left {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      align-items: center;
    }

    .badge {
      font-size: 13px;
      color: var(--muted);
      border: 1px solid var(--border);
      padding: 6px 10px;
      border-radius: 999px;
      background: rgba(255,255,255,0.02);
      white-space: nowrap;
    }

    .btns {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    button {
      border: 1px solid var(--border);
      background: rgba(255,255,255,0.04);
      color: var(--text);
      padding: 8px 12px;
      border-radius: 10px;
      font-size: 14px;
      cursor: pointer;
      transition: 120ms ease;
    }

    button:hover {
      transform: translateY(-1px);
      border-color: rgba(255,255,255,0.22);
      background: rgba(255,255,255,0.07);
    }

    button.primary {
      border-color: rgba(56,189,248,0.35);
      background: rgba(56,189,248,0.08);
    }

    .progress-wrap {
      padding: 10px 14px 12px;
      border-bottom: 1px solid var(--border);
    }

    .progress-row {
      display: flex;
      justify-content: space-between;
      gap: 10px;
      font-size: 13px;
      color: var(--muted);
      margin-bottom: 8px;
    }

    .bar {
      height: 8px;
      border-radius: 999px;
      background: rgba(255,255,255,0.07);
      overflow: hidden;
      border: 1px solid rgba(255,255,255,0.05);
    }

    .bar > div {
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, var(--accent), var(--accent2));
      transition: width 120ms ease;
    }

    .verses {
      max-height: 72vh;
      overflow: auto;
      padding: 14px;
    }

    .verse-row {
      display: grid;
      grid-template-columns: 42px 1fr;
      gap: 10px;
      align-items: start;
      margin-bottom: 8px;
    }

    .verse-no {
      color: var(--muted);
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
      font-size: 14px;
      line-height: 2.2;
      text-align: right;
      user-select: none;
      padding-top: 2px;
    }

    .verse-line {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 0;
      row-gap: 8px;
      min-width: 0;
    }

    .static {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
      font-size: 15px;
      line-height: 1;
      color: var(--muted);
      white-space: pre;
      user-select: none;
    }

    .punct {
      color: #cbd5e1;
    }

    .slot {
      position: relative;
      display: inline-block;
      min-width: 3ch;
      width: calc(var(--w) * 0.68em + 18px);
      height: 34px;
      margin: 0 1px;
      border-radius: 9px;
      border: 1px solid rgba(255,255,255,0.16);
      background: rgba(255,255,255,0.03);
      box-shadow: inset 0 -1px 0 rgba(255,255,255,0.03);
      overflow: hidden;
      vertical-align: middle;
    }

    .slot:focus-within {
      border-color: rgba(56,189,248,0.45);
      box-shadow: 0 0 0 2px rgba(56,189,248,0.16);
    }

    .slot.has-error {
      border-color: rgba(239,68,68,0.5);
    }

    .slot.is-complete {
      border-color: rgba(34,197,94,0.35);
    }

    .slot-display, .slot-input {
      position: absolute;
      inset: 0;
      padding: 6px 8px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
      font-size: 15px;
      line-height: 20px;
      white-space: pre;
      letter-spacing: 0;
    }

    .slot-display {
      pointer-events: none;
      color: var(--text);
      z-index: 1;
    }

    .slot-display .ok { color: var(--text); }
    .slot-display .hinted { color: var(--hinted); }
    .slot-display .bad {
      color: var(--wrong);
      text-decoration: underline;
      text-decoration-color: rgba(239,68,68,0.6);
      text-underline-offset: 2px;
    }

    .slot-display .ghost {
      color: rgba(148,163,184,0.22);
    }

    .slot-input {
      z-index: 2;
      border: 0;
      outline: none;
      width: 100%;
      height: 100%;
      background: transparent;
      color: transparent;          /* hide native text */
      caret-color: #fff;           /* keep caret */
    }

    .slot-input::selection {
      background: rgba(255,255,255,0.12);
      color: transparent;
    }

    .footer-note {
      padding: 10px 14px 14px;
      font-size: 12px;
      color: var(--muted);
      border-top: 1px solid var(--border);
    }

    @media (max-width: 700px) {
      .verse-row { grid-template-columns: 34px 1fr; gap: 8px; }
      .verse-no { font-size: 13px; }
      .slot { height: 32px; }
      .slot-display, .slot-input { font-size: 14px; padding: 6px 7px; }
      .static { font-size: 14px; }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <div class="topbar">
        <div class="left">
          <div class="badge">Matteus 5 • Fjallaprædikan</div>
          <div class="badge" id="mistakesBadge">Feilir: 0</div>
          <div class="badge" id="slotsBadge">Slots: 0</div>
        </div>
        <div class="btns">
          <button class="primary" id="hintWordBtn" type="button">Hint (Word)</button>
          <button class="primary" id="hintBoxBtn" type="button">Hint (Box)</button>
          <button id="clearBtn" type="button">Clear</button>
        </div>
      </div>

      <div class="progress-wrap">
        <div class="progress-row">
          <span id="progressText">0 / 0 chars correct in sequence</span>
          <span id="percentText">0%</span>
        </div>
        <div class="bar"><div id="barFill"></div></div>
      </div>

      <div class="verses" id="verses"></div>

      <div class="footer-note">
        Thomas Warner er GAY
      </div>
    </div>
  </div>

  <script>
    // Full chapter text with verse numbers (used to auto-build rows)
    const rawTargetText = `1
Táið Hann nú sá fólkið, fór Hann niðan á fjallið, og táið Hann hevði sett Seg, komu lærisveinar Hansara til Hansara.

2
Hann læt tá upp munnin, lærdi teir og segði:

3
„Sæl eru hini fátæku í anda; tí ríki Himmiríkis er teirra.

4
Sæl eru tey, sum syrgja; tí tey skulu verða troystað.

5
Sæl eru hini spakføru; tí tey skulu arva jørðina.

6
Sæl eru tey, sum hungra og tysta eftir rættvísi; tí tey skulu verða mettað.

7
Sæl eru hini miskunnsomu; tí tey skulu finna miskunn.

8
Sæl eru hini hjartareinu; tí tey skulu síggja Gud.

9
Sæl eru tey, sum fáa frið í lag; tí tey skulu kallast børn Guds.

10
Sæl eru tey, sum eru atsøkt fyri rættvísi skuld; tí ríki Himmiríkis er teirra.

11
Sæl eru tit, táið tey spotta tykkum og søkja at tykkum og lúgva alt ilt um tykkum fyri Mína skuld.

12
Gleðist og fegnist! Tí løn tykkara er stór í Himli; soleiðis søktu tey at profetunum, ið vóru fyri tykkum.

13
Tit eru salt jarðarinnar; men missir saltið kraft sína, hvussu skal tað aftur verða salt! Tað dugir einki longur uttan at verða kastað út og traðkað niður av menniskjum.

14
Tit eru ljós heimsins; staður, ið stendur á fjalli, fjalist ikki.

15
Tey tendra heldur ikki ljós og seta tað undir skeppumálið – nei, í ljósastakan; so lýsir tað øllum í húsinum.

16
Latið soleiðis ljós tykkara lýsa menniskjum, so tey kunnu síggja góðu verk tykkara og æra Faðir tykkara, sum er í Himli!

17
Hugsið ikki, at Eg eri komin at seta lógina úr gildi – ella profetarnar! Eg eri ikki komin at seta úr gildi, men at fullkoma.

18
Tí sanniliga, sigi Eg tykkum: Inntil Himmal og jørð forganga, skal ikki minsti bókstavur ella prikkur av lógini forganga, fyrrenn tað alt hevur hent.

19
Hvør tann, sum tí brýtur eitt hitt minsta av hesum boðum og lærir menniskju so, skal kallast hin minsti í ríki Himmiríkis; men tann, ið heldur tey og lærir tey, skal kallast stórur í ríki Himmiríkis.

20
Tí Eg sigi tykkum: Er rættvísi tykkara ikki mætari enn rættvísi hinna skriftlærdu og Farisearanna, koma tit als ikki inn í ríki Himmiríkis.

21
Tit hava hoyrt, at sagt varð við hinar gomlu: „Tú mást ikki drepa; og tann, ið drepur, skal vera sekur fyri dóminum.“

22
Men Eg sigi tykkum, at hvør tann, sum uttan grund er illur við bróður sín, skal vera sekur fyri dóminum. Tann, ið sigur við bróður sín: „Raka!“* skal vera sekur fyri ráðnum, og tann, ið sigur: „Dári tín!“ skal vera sekur til eld Helvitis.

23
Um tær tí kemur í hug, táið tú bert fram gávu tína á altarið, at bróðir tín hevur okkurt ímóti tær,

24
lat tá gávu tína liggja har framman fyri altarið og far og verð fyrst samdur við bróður tín – kom so og ber fram gávu tína!

25
Ver skjótur til semju við mótpart tín, meðan tú enn ert á vegnum við honum, so ikki mótparturin letur teg dómaranum í hendur, og dómarin letur teg tænaranum í hendur, og tú verður settur í fangahús!

26
Sanniliga, sigi Eg tær: Tú skalt als ikki sleppa út haðani, fyrrenn tú hevur goldið síðsta oyrað.

27
Tit hava hoyrt, at sagt er: „Tú mást ikki dríva hor.“

28
Men Eg sigi tykkum, at hvør tann, ið hyggur á kvinnu og hevur hug á henni, hevur longu drivið hor við henni í hjarta sínum.

29
Um nú høgra eyga títt freistar teg, so rív tað út og kasta tað frá tær! Tað er tær betri, at ein limur tín verður forkomin, enn at alt likam títt verður kastað í Helviti.

30
Og um høgra hond tín freistar teg, so høgg hana av og kasta hana frá tær! – Tað er tær betri, at ein limur tín verður forkomin, enn at alt likam títt verður kastað í Helviti.

31
Eisini er sagt: „Tann, ið skilst frá konu síni, skal geva henni skilnaðarbræv.“

32
Men Eg sigi tykkum, at hvør tann, ið skilst frá konu síni fyri nakað annað enn hor, ger, at hon drívur hor, og hvør tann, ið tekur fráskilda kvinnu til ekta, drívur hor.

33
Uppaftur hava tit hoyrt, at sagt er við hinar gomlu: „Tú mást ikki svørja rangan eið; nei, tú skalt halda Harranum eiðir tínar.“

34
Men Eg sigi tykkum, at tit skulu als ikki svørja – ikki um Himmalin, tí hann er hásæti Guds;

35
ei heldur um jørðina, tí hon er fótaskammul Hansara; ei heldur um Jerusalem, tí tað er staður hins stóra kongs;

36
ei heldur mást tú svørja um høvd títt, tí tú fært ikki gjørt hár hvítt ella svart.

37
Nei, tala tykkara skal vera: „Ja, ja, nei, nei,“ og tað, sum meir er enn hetta, er av hinum illa.

38
Tit hava hoyrt, at sagt er: „Eyga fyri eyga, og tonn fyri tonn!“

39
Men Eg sigi tykkum, at tit skulu ikki seta tykkum ímóti hinum illa; nei, slær onkur teg undir høgra vanga, so vend honum hin við!

40
Vil onkur saksøkja teg og taka kyrtil tín, so lat hann fáa kappan við!

41
Og noyðir onkur teg at ganga eina míl við sær, so gakk tvær við honum!

42
Gev tí, sum biður teg, og vend tær ikki frá tí, sum vil læna frá tær!

43
Tit hava hoyrt, at sagt er: „Tú skalt elska næsta tín og hata fígginda tín!“

44
Men Eg sigi tykkum: Elskið fíggindar tykkara, signið tey, sum banna tykkum, gerið teimum gott, sum hata tykkum, og biðið fyri teimum, ið háða tykkum og søkja at tykkum

45
– fyri at tit kunnu verða børn Faðirs tykkara, sum í Himli er! Tí Hann letur sól Sína renna upp yvir ónd og góð og letur regna yvir rættvís og órættvís.

46
Tí um tit elska tey, sum elska tykkum, hvørja løn eiga tit fyri tað! Gera ikki eisini tollararnir tað sama!

47
Og um tit heilsa bert brøðrum tykkara, hvat stórt gera tit tá! Gera ikki eisini heidningarnir so!

48
Tit skulu tí vera fullkomin, eins og himmalski Faðir tykkara er fullkomin.“`;

    const versesEl = document.getElementById('verses');
    const mistakesBadge = document.getElementById('mistakesBadge');
    const slotsBadge = document.getElementById('slotsBadge');
    const progressText = document.getElementById('progressText');
    const percentText = document.getElementById('percentText');
    const barFill = document.getElementById('barFill');
    const hintWordBtn = document.getElementById('hintWordBtn');
    const hintBoxBtn = document.getElementById('hintBoxBtn');
    const clearBtn = document.getElementById('clearBtn');

    const slots = []; // {el,input,display,target,verseNo,index,hinted:Set<int>}
    const PUNCT = new Set([",",";",".",":","!","?","„","“","\"","–","*","(",")"]);

    function parseVerseText(raw) {
      const lines = raw.replace(/\r\n/g, '\n').split('\n');
      const verseNumbers = [];
      const verses = [];
      let currentNo = null;
      let currentText = [];

      for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        const trimmed = line.trim();

        if (/^\d+$/.test(trimmed)) {
          if (currentNo !== null) verses.push(currentText.join('\n').trimEnd());
          currentNo = trimmed;
          verseNumbers.push(trimmed);
          currentText = [];
          while (i + 1 < lines.length && lines[i + 1] === '') i++;
        } else {
          currentText.push(line);
        }
      }
      if (currentNo !== null) verses.push(currentText.join('\n').trimEnd());
      return { verseNumbers, verses };
    }

    function tokenizeVerse(verse) {
      const tokens = [];
      let buf = "";

      const flushText = () => {
        if (!buf) return;
        const raw = buf;
        buf = "";

        const lead = (raw.match(/^\s+/) || [""])[0];
        const trail = (raw.match(/\s+$/) || [""])[0];
        const core = raw.slice(lead.length, raw.length - trail.length);

        if (lead) tokens.push({ type: "space", text: lead });
        if (core) tokens.push({ type: "chunk", text: core });
        if (trail) tokens.push({ type: "space", text: trail });
      };

      for (const ch of verse) {
        if (PUNCT.has(ch)) {
          flushText();
          tokens.push({ type: "punct", text: ch });
        } else {
          buf += ch;
        }
      }
      flushText();

      return tokens;
    }

    function esc(s) {
      return s.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
    }

    function visibleChar(ch) {
      return ch === " " ? "&nbsp;" : esc(ch);
    }

    function normChar(ch) {
      return ch.toLocaleLowerCase("fo");
    }

    function sameChar(a, b) {
      return normChar(a) === normChar(b);
    }

    function isSlotFullyCorrect(slot) {
      if (slot.input.value.length !== slot.target.length) return false;
      for (let i = 0; i < slot.target.length; i++) {
        if (!sameChar(slot.input.value[i], slot.target[i])) return false;
      }
      return true;
    }

    function firstIncompleteIndex(slot) {
      const typed = slot.input.value;
      const target = slot.target;
      for (let i = 0; i < target.length; i++) {
        if (i >= typed.length) return i;
        if (!sameChar(typed[i], target[i])) return i;
      }
      return -1;
    }

    function setRangeToTarget(slot, start, end) {
      const typed = slot.input.value;
      const needLen = Math.max(typed.length, end);
      const chars = new Array(needLen);

      for (let i = 0; i < needLen; i++) {
        if (i < typed.length) chars[i] = typed[i];
        else chars[i] = ""; // temporary
      }

      // If we need to extend length, fill only the new part with target chars
      for (let i = typed.length; i < needLen; i++) {
        chars[i] = slot.target[i] ?? "";
      }

      // Apply revealed range
      for (let i = start; i < end; i++) {
        chars[i] = slot.target[i];
        slot.hinted.add(i);
      }

      slot.input.value = chars.join("");
    }

    function renderSlot(slot) {
      const typed = slot.input.value;
      const target = slot.target;

      let html = "";
      let hasError = false;
      let completeCorrect = typed.length === target.length;

      for (let i = 0; i < typed.length; i++) {
        const ok = i < target.length && sameChar(typed[i], target[i]);
        if (!ok) hasError = true;

        let cls = "bad";
        if (ok) cls = slot.hinted.has(i) ? "hinted" : "ok";

        html += `<span class="${cls}">${visibleChar(typed[i])}</span>`;
      }

      // faint dots for remaining chars
      for (let i = typed.length; i < target.length; i++) {
        html += `<span class="ghost">${target[i] === " " ? "&nbsp;" : "·"}</span>`;
      }

      if (!html) html = "&nbsp;";

      if (typed.length !== target.length) completeCorrect = false;
      if (hasError) completeCorrect = false;

      slot.display.innerHTML = html;
      slot.el.classList.toggle("has-error", hasError);
      slot.el.classList.toggle("is-complete", completeCorrect);
    }

    function renderAll() {
      let mistakes = 0;
      let totalChars = 0;
      let prefix = 0;
      let prefixStopped = false;

      for (const slot of slots) {
        renderSlot(slot);

        const typed = slot.input.value;
        const target = slot.target;
        totalChars += target.length;

        for (let i = 0; i < typed.length; i++) {
          if (i >= target.length || !sameChar(typed[i], target[i])) mistakes++;
        }

        // correct prefix across all slots
        if (!prefixStopped) {
          const n = Math.min(typed.length, target.length);
          for (let i = 0; i < n; i++) {
            if (sameChar(typed[i], target[i])) {
              prefix++;
            } else {
              prefixStopped = true;
              break;
            }
          }
          if (!prefixStopped && typed.length < target.length) {
            prefixStopped = true;
          }
        }
      }

      const pct = totalChars ? Math.floor((prefix / totalChars) * 100) : 0;
      mistakesBadge.textContent = `Feilir: ${mistakes}`;
      slotsBadge.textContent = `Kassar: ${slots.length}`;
      progressText.textContent = `${prefix} / ${totalChars} stavir rættir á rað`;
      percentText.textContent = `${pct}%`;
      barFill.style.width = `${pct}%`;
    }

    function focusSlot(slot, toEnd = true) {
      slot.input.focus();
      const pos = toEnd ? slot.input.value.length : 0;
      slot.input.setSelectionRange(pos, pos);
      slot.el.scrollIntoView({ block: "nearest", inline: "nearest" });
    }

    function buildUI() {
      const { verseNumbers, verses } = parseVerseText(rawTargetText);
      versesEl.innerHTML = "";
      slots.length = 0;

      let slotCounter = 0;

      for (let i = 0; i < verses.length; i++) {
        const verseNo = verseNumbers[i];
        const verse = verses[i];
        const tokens = tokenizeVerse(verse);

        const row = document.createElement("div");
        row.className = "verse-row";

        const no = document.createElement("div");
        no.className = "verse-no";
        no.textContent = verseNo + ".";

        const line = document.createElement("div");
        line.className = "verse-line";

        for (const token of tokens) {
          if (token.type === "space") {
            const span = document.createElement("span");
            span.className = "static";
            span.textContent = token.text;
            line.appendChild(span);
          } else if (token.type === "punct") {
            const span = document.createElement("span");
            span.className = "static punct";
            span.textContent = token.text;
            line.appendChild(span);
          } else if (token.type === "chunk") {
            const slot = document.createElement("div");
            slot.className = "slot";
            slot.style.setProperty("--w", Math.max(token.text.length, 3));

            const display = document.createElement("div");
            display.className = "slot-display";
            display.setAttribute("aria-hidden", "true");

            const input = document.createElement("input");
            input.className = "slot-input";
            input.type = "text";
            input.autocomplete = "off";
            input.autocapitalize = "off";
            input.spellcheck = false;
            input.maxLength = token.text.length;
            input.dataset.index = String(slotCounter);

            slot.appendChild(display);
            slot.appendChild(input);
            line.appendChild(slot);

            const slotObj = {
              el: slot,
              input,
              display,
              target: token.text,
              verseNo,
              index: slotCounter,
              hinted: new Set()
            };
            slots.push(slotObj);
            slotCounter++;
          }
        }

        row.appendChild(no);
        row.appendChild(line);
        versesEl.appendChild(row);
      }

      for (let i = 0; i < slots.length; i++) {
        const current = slots[i];
        const next = slots[i + 1] || null;
        const prev = slots[i - 1] || null;

        current.input.addEventListener("input", () => {
          if (current.input.value.length > current.target.length) {
            current.input.value = current.input.value.slice(0, current.target.length);
          }

          renderAll();

          if (next && current.input.value.length >= current.target.length) {
            next.input.focus();
            next.input.select();
          }
        });

        current.input.addEventListener("keydown", (e) => {
          if (e.key === "Backspace" &&
              current.input.selectionStart === 0 &&
              current.input.selectionEnd === 0 &&
              current.input.value.length === 0 &&
              prev) {
            e.preventDefault();
            prev.input.focus();
            prev.input.setSelectionRange(prev.input.value.length, prev.input.value.length);
          }

          if (e.key === "ArrowLeft" &&
              current.input.selectionStart === 0 &&
              current.input.selectionEnd === 0 &&
              prev) {
            prev.input.focus();
            prev.input.setSelectionRange(prev.input.value.length, prev.input.value.length);
          }

          if (e.key === "ArrowRight" &&
              current.input.selectionStart === current.input.value.length &&
              current.input.selectionEnd === current.input.value.length &&
              next) {
            next.input.focus();
            next.input.setSelectionRange(0, 0);
          }

          if (e.key === "Enter") {
            e.preventDefault();
            if (next) {
              next.input.focus();
              next.input.select();
            }
          }
        });

        current.input.addEventListener("paste", (e) => {
          e.preventDefault();
          const txt = (e.clipboardData || window.clipboardData).getData("text");
          current.input.value = txt.slice(0, current.target.length);
          renderAll();
        });
      }

      renderAll();
      if (slots[0]) slots[0].input.focus();
    }

    function revealNextBox() {
      for (const slot of slots) {
        if (!isSlotFullyCorrect(slot)) {
          setRangeToTarget(slot, 0, slot.target.length);
          renderAll();
          focusSlot(slot);
          return;
        }
      }
    }

    function revealNextWord() {
      for (const slot of slots) {
        if (isSlotFullyCorrect(slot)) continue;

        const idx = firstIncompleteIndex(slot);
        if (idx === -1) continue;

        const t = slot.target;
        let start = idx;
        let end = idx;

        // If we're on spaces, reveal spaces + next word
        if (t[start] === " ") {
          while (end < t.length && t[end] === " ") end++;
          while (end < t.length && t[end] !== " ") end++;
        } else {
          // Reveal current word until next space
          while (end < t.length && t[end] !== " ") end++;
        }

        setRangeToTarget(slot, start, end);
        renderAll();
        focusSlot(slot);
        return;
      }
    }

    function clearAll() {
      for (const slot of slots) {
        slot.input.value = "";
        slot.hinted.clear();
      }
      renderAll();
      if (slots[0]) {
        slots[0].input.focus();
        slots[0].input.setSelectionRange(0, 0);
      }
    }

    hintWordBtn.addEventListener("click", revealNextWord);
    hintBoxBtn.addEventListener("click", revealNextBox);
    clearBtn.addEventListener("click", clearAll);

    buildUI();
  </script>
</body>
</html>
